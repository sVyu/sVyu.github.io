---
title: "[BOJ] 백준 2357번 최솟값과 최댓값"
excerpt: "조금씩 익숙해져 가는 세그먼트 트리 :)"

categories:
  - Algorithm
tags:
  - [algorithm, backjoon, boj, segment_tree]

permalink: /algorithm/boj_2357/

toc: true
toc_sticky: true

date: 2023-02-21
last_modified_at: 2023-02-22

# classes: wide

header:
  teaser: "/assets/images/posts_img/boj_2357/image2.png"
---

<h1 style="color:#fa7e1e">Segment tree :)</h1>

## <span style="color:#fa7e1e"># [BOJ 2357 최솟값과 최댓값][link1] </span>


<br/>

## <span style="color:#d62976"> ◎ 세그먼트 트리의 개념 </span>

[개념 참고 링크 1 : 네이버 블로그](https://m.blog.naver.com/ndb796/221282210534)

[개념 참고 링크 2 : BOJ 블로그](https://www.acmicpc.net/blog/view/9)

[개념 참고 링크 3 : BOJBOOK](https://book.acmicpc.net/ds/segment-tree)


세그먼트 트리에 대한 개념과 그에 대한 이해는 이상의 사이트들을 참고하여 진행했습니다

<b>결국 <span style="color:#d62976">이진 트리로 재구성하여</span> 재귀적인 방법 등으로 <span style="color:#d62976">구간 합을 구하는 자료구조</span>임을 이해했습니다</b>

<br />

<b>일반 배열의 탐색 및 수정</b>

|           |  일반 배열  | <b style="color:#d62976">세그먼트 트리</b> |
|-----------|-------------|--------------|
|<b style="color:#d62976">탐색</b> |     O(N)    |<b style="color:#d62976">O(logN)</b>|
|   수정    |      1      |   O(logN)    |

[link1]:https://www.acmicpc.net/problem/2357

<br />

## <b><span style="color:#d62976">◎ if not segment-tree :</span> </b>
>만약 이 문제에서 세그먼트 트리나 그에 준하는 자료구조를 쓰지 않는다면?

<b> 컴퓨터의 연산 횟수는 보편적으로 1초당 1억 번의 연산을 기준으로 합니다 </b>

[참고 링크 1: 네이버 블로그](https://post.naver.com/viewer/postView.naver?volumeNo=27517848&memberNo=5565159)

[참고 링크 2: 티스토리 블로그](https://lemonlemon.tistory.com/54)

[참고 링크 3: 백준 게시판](https://www.acmicpc.net/board/view/39001)


<br />

<b> 다시 말해서 일반 <span style="color:#d62976">배열(리스트)로 접근하면</span> 문제의 N과 M이 각각 최대 10만 == int(1e5), </b>
  
<b>이를 곱하면 int(1e10)인 100억 즉, <span style="color:#d62976">100초</span>가 걸리기에 <span style="color:#d62976">시간제한인 2초 안에 불가능합니다</span></b>

<b><span style="color:#d62976">세그먼트 트리</span>의 경우 <span style="color:#d62976">MlogN 이므로 약 160만 번</span></b>

<b>C++ 기준으로 <span style="color:#d62976">약 160ms (0.16초)로 수행 가능</span>하고 <span style="color:#d62976">느린 파이썬으로도 충분히 가능합니다</span></b>

```python
import math
print(math.log2(int(1e5)))

# result : 16.609640474436812
```

<img src="/assets/images/posts_img/boj_2357/image1.png" width="100%" height="100%"  alt="img_not_loaded">  

[log 참고 링크 1 : 티스토리 블로그](https://astrocosmos.tistory.com/221)

[log 참고 링크 2 : OurCalc](https://ourcalc.com/log-calculator/)



<br />

## <span style="color:#d62976"> ◎ code 작성 → 시간 초과</span>

```python
import sys
input = sys.stdin.readline

def init(start, end, node, nums, tree):
    if start == end:
        tree[node] = [nums[start], nums[start]]
        return tree[node]

    mid = (start+end)//2
    tree[node][0] = min(init(start, mid, node*2, nums, tree)[0], init(mid+1, end, node*2+1, nums, tree)[0])
    tree[node][1] = max(init(start, mid, node*2, nums, tree)[1], init(mid+1, end, node*2+1, nums, tree)[1])
    return tree[node]

def show(start, end, node, left, right, tree):
    if (right < start) or (end < left): return [int(1e9), 1]
    elif (left <= start) and (end <= right):
        return tree[node]

    mid = (start+end)//2
    return [min(show(start, mid, node*2, left, right, tree)[0], show(mid+1, end, node*2+1, left, right, tree)[0]),
            max(show(start, mid, node*2, left, right, tree)[1], show(mid+1, end, node*2+1, left, right, tree)[1])]

def solve():
    N, M = map(int, input().split())
    nums = [int(input()) for _ in range(N)]
    tree = [[0, 0] for _ in range(4*N)]

    init(0, N-1, 1, nums, tree)
    # print(tree)

    for _ in range(M):
        l, r = map(int, input().split())
        print(*show(0, N-1, 1, l-1, r-1, tree))

solve()
```

> 최솟값과 최댓값을 하나의 트리로 구할 수 있게 각 노드를 [0, 0]으로 설정하였습니다

하지만 <span style="color:#d62976">시간 초과</span>가 났기에 게시판의 모든 Q&A를 살펴보며 개선 가능한 부분을 찾았습니다

<span style="color:#d62976">이유는 크게 2가지</span>였습니다
1. <b>tree 크기</b>를 더 작게 설정할 수 있다
2. <b>(핵심) 재귀의 수행 횟수</b>가 예상치를 크게 웃돈다

<br />

### <span style="color:#d62976">◎ 1 - tree 크기 최적화</span>

<span style="color:#d62976">위 코드는</span> tree 크기에 대해 4*N을 적용하고 있습니다   
<span style="color:#d62976">경우에 따라 필요치의 약 2배를 차지할 수 있다</span>는 점을 인지하여 개선하였습니다

[tree 크기 참고 : 백준 게시판](https://www.acmicpc.net/board/view/20847)

```python
def cal_tree_len(N):
    tree_len = 1
    while tree_len < N:
        tree_len *= 2   # [1]
    tree_len *= 2       # [2]
    return tree_len
```

tree의 길이가 2배씩 증가하므로
[ 1 ]까지 수행 했을 때 루트 노드의 level을 1이라 하면  
<span style="color:#d62976">tree_len</span>은 (곱한 횟수 + 1)의 depth를 가지는 <span style="color:#d62976"> 포화 이진 트리의 가장 마지막 level의 노드들의 개수</span>와 같습니다 

<span style="color:#d62976">해당 tree_len을 가지는 N의 가능한 가장 큰 N값은 마찬가지로 포화 이진 트리일 때</span> 이므로   
<img src="/assets/images/posts_img/boj_2357/image2.png" width="100%" height="100%"  alt="img_not_loaded"> 

n을 트리의 level, a<sub>n</sub>을 해당 level의 노드 수, S<sub>n</sub>을 해당 level까지의 총 노드 수라 한다면   
a<sub>n</sub>은 공비가 2인 공비수열을 이루므로,

<br/>

<p align="center">
<!-- a_n = 2^{n-1}\; (\; n = \ulcorner \log_{2}(S_n+1) \urcorner\; ) -->
<img src="/assets/images/posts_img/boj_2357/latex_1.svg" width="77%" height="77%"  alt="img_not_loaded"> 

<!-- S_n = {a_1(r^n -1) \over{r-1}} = 2^n -1 \; (\ \because r = 2) -->
<img src="/assets/images/posts_img/boj_2357/latex_2.svg" width="77%" height="77%"  alt="img_not_loaded"> 

</p>

<br />
여기서 트리의 depth를 d라고 한다면,
<p align="center">
<!-- 2 * treelen >= 2*N = 2*a_d = 2^d > 2^d - 1 = S_d  -->
<img src="/assets/images/posts_img/boj_2357/latex_3.svg" width="85%" height="85%"  alt="img_not_loaded"> 
</p>

따라서 2 * tree_len 은 S<sub>d</sub>보다 크므로   
<span style="color:#d62976">[ 2 ]까지 수행했을 때 index error가 발생하지 않는 충분한 크기의 tree로 최적화</span> 할 수 있습니다

<br />

### <span style="color:#d62976">◎ 2 - 재귀함수 호출 횟수</span>

게시판을 살펴보니 재귀 함수의 값을 저장해서 반환하는 형식을 취해야 한다는 답변을 보았습니다

재귀함수 호출이나 return 관련 알고리즘에 문제가 있나 싶어 <span style="color:#d62976">cnt를 찍어보니 예상보다 높습니다</span>
```python
def init(start, end, node, nums, tree):
    global cnt
    cnt += 1

    if start == end:
        tree[node] = [nums[start], nums[start]]
        return tree[node]

    mid = (start+end)//2
    tree[node][0] = min(init(start, mid, node*2, nums, tree)[0], init(mid+1, end, node*2+1, nums, tree)[0])
    tree[node][1] = max(init(start, mid, node*2, nums, tree)[1], init(mid+1, end, node*2+1, nums, tree)[1])
    return tree[node]
```
```python
def solve():
    N, M = map(int, input().split())
    nums = [int(input()) for _ in range(N)]
    tree = [[0, 0] for _ in range(4*N)]

    global cnt
    cnt = 0

    init(0, N-1, 1, nums, tree)

    print("cnt", cnt)
```

이유를 살펴보니 init만 봐도 왼쪽 구간, 오른쪽 구간 init()을 2번씩 하기 때문에   
2의 배수로 값이 커지는 것이었습니다
<span style="color:#d62976">input이 이하와 같다면</span>
```python
4 2
1
2
3
4
1 2
2 3
```

기대 호출 횟수 (cnt) : <span style="color:#d62976">13</span>   
<span style="color:#d62976">실제 출력 (cnt) : 21</span>
<img src="/assets/images/posts_img/boj_2357/image3.png" width="100%" height="100%"  alt="img_not_loaded"> 

21 == 1 + (2 * 2) + (4 * 4)

level이 커질수록 2배로 호출하기 때문에 아주 당연하게 시간 초과가 발생합니다   
이에 맞춰 코드를 수정하여 통과했습니다 :)

<br />

## <span style="color:#d62976"> ◎ 통과 </span>

```python
import sys
input = sys.stdin.readline

def init(start, end, node, nums, tree, check_child):
    if start == end:
        tree[node] = [nums[start], nums[start]]
        return tree[node]

    mid = (start+end)//2
    if check_child:
        tree[node][0] = min(init(start, mid, node*2, nums, tree, True)[0], init(mid+1, end, node*2+1, nums, tree, True)[0])
        tree[node][1] = max(init(start, mid, node*2, nums, tree, False)[1], init(mid+1, end, node*2+1, nums, tree, False)[1])
    return tree[node]

def show(start, end, node, left, right, tree):
    if (right < start) or (end < left): return [int(1e9), 1]
    elif (left <= start) and (end <= right):
        return tree[node]

    mid = (start+end)//2
    left_child, right_child = show(start, mid, node*2, left, right, tree), show(mid+1, end, node*2+1, left, right, tree)
    return [min(left_child[0], right_child[0]), max(left_child[1], right_child[1])]

def cal_tree_len(N):
    tree_len = 1
    while tree_len < N:
        tree_len *= 2
    tree_len *= 2
    return tree_len

def solve():
    N, M = map(int, input().split())
    nums = [int(input()) for _ in range(N)]

    tree = [[0, 0] for _ in range(cal_tree_len(N))]

    init(0, N-1, 1, nums, tree, True)

    for _ in range(M):
        l, r = map(int, input().split())
        print(*show(0, N-1, 1, l-1, r-1, tree))

solve()
```
<img src="/assets/images/posts_img/boj_2357/image4.png" width="100%" height="100%"  alt="img_not_loaded"> 

<img src="/assets/images/posts_img/boj_2357/image5.png" width="100%" height="100%"  alt="img_not_loaded"> 

BOJ <span style="color:#d62976">Ruby</span>, Codeforces <span style="color:red">grandmaster</span> 달성하는 그 날까지 한 걸음씩 : )

<br />

- [color 참고 : color-hex](https://www.color-hex.com/color-palette/44340)   
- [그림 : draw.io](https://draw.io/)
- Tex (md파일 수식)
    - [wiki](https://ko.wikipedia.org/wiki/%EC%9C%84%ED%82%A4%EB%B0%B1%EA%B3%BC:TeX_%EB%AC%B8%EB%B2%95)
    - [수식 error 판단](https://latex.codecogs.com/eqneditor/editor.php)
    - [svg 저장](https://editor.codecogs.com/)
    - [md 관련 github](https://github.com/zeuseyera/Markdown_TongDal-kr)